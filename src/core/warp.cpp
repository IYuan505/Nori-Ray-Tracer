/*
    This file is part of Nori, a simple educational ray tracer

    Copyright (c) 2015 by Wenzel Jakob

    Nori is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License Version 3
    as published by the Free Software Foundation.

    Nori is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#include <nori/warp.h>
#include <nori/vector.h>
#include <nori/frame.h>

NORI_NAMESPACE_BEGIN

Point2f Warp::squareToUniformSquare(const Point2f &sample) {
    return sample;
}

float Warp::squareToUniformSquarePdf(const Point2f &sample) {
    return ((sample.array() >= 0).all() && (sample.array() <= 1).all()) ? 1.0f : 0.0f;
}

Point2f Warp::squareToTent(const Point2f &sample) {
    /* The distribution is composed of two independent 1D distributions,
     * therefore, we can consider one axis at a time. 
     * The CDF of the 1D distrubution is:
     *    y =  1/2 * (x + 1)^2      , if -1 <= x <=0
     *      = -1/2 * (x - 1)^2 + 1  , if  0 <= x <= 1
     * The inverse CDF is:
     *    x =  sqrt(2 * y) - 1      , if 0   <= y <= 0.5
     *      = -sqrt(2 - 2 * y) + 1  , if 0.5 <= y <= 1
     */

    auto tentInverseCdf = [](float t) {
        return (t < 0.5) ? (sqrt(2 * t) - 1) : (-sqrt(2 - 2 * t) + 1);
    };
    return Point2f(tentInverseCdf(sample.x()), tentInverseCdf(sample.y()));
}

float Warp::squareToTentPdf(const Point2f &p) {
    /* Same for Pdf, we can consider one axis at a time.
     * The PDF of the 1D distribution is:
     *    p = 1 - |t|, if -1 <= t <= 1
     *      = 0      , otherwise
     */
    auto tentPdf = [](float t) {
        return (t >= -1 && t <= 1) ? 1 - abs(t) : 0;
    };
    return tentPdf(p.x()) * tentPdf(p.y());
}

Point2f Warp::squareToUniformDisk(const Point2f &sample) {
    /* Convert to the polar coordinates, which contain r and theta. We map 
     * x to r, and y to theta. To counter the effect of distortion by 
     * coordinate system, we need r / (2 * pi) on the source domain.
     * To match the desirable distribution, we generate r proportional to r,
     * and generate theta uniform (no special handling).
     * The CDF of the r is:
     *    y = r^2, 0 <= r <= 1
     * The inverse CDF is:
     *    r = sqrt(y)
     * The CDF of the theta is:
     *    y = theta / (2 * pi), 0 <= theta <= 2 * pi
     * The inverse of CDF is:
     *    theta = y * 2 * pi
     */
    float r, theta;
    r = sqrt(sample.x());
    theta = sample.y() * 2 * M_PI;
    return Point2f(r * cos(theta), r * sin(theta));
}

float Warp::squareToUniformDiskPdf(const Point2f &p) {
    /* The PDF of a 2D point is:
     *    p = 1 / pi, if x^2 + y^2 <= 1
     *      = 0     , otherwise
     */
    return (p.x() * p.x() + p.y() * p.y() <= 1) ? INV_PI : 0;
}

Vector3f Warp::squareToUniformSphere(const Point2f &sample) {
    /* To sample points on sphere, we use the spherical coordinate that 
     * uniquely identify a point. To optimize the algorithm execution 
     * speed, we do not directly sampling theta and phi, instead, we
     * sample the z component of the vector, and theta. Both of them can
     * be uniformly sampled.
     * The CDF of z is:
     *    y = 1 / 2 * x + 1 / 2, -1 <= z <= 1
     * The inverse CDF is:
     *    x = 2 * y - 1
     * The CDF of theta is the same as UniformDisk
     */
    float z, theta, r; // r is the component on the x-y plane
    z = 2 * sample.x() - 1;
    theta = sample.y() * 2 * M_PI;
    r = sqrt(1 - z * z);
    return Vector3f(r * cos(theta), r * sin(theta), z);
}

float Warp::squareToUniformSpherePdf(const Vector3f &v) {
    /* The PDF of a 3D point is (the surface area of a sphere is 4 * pi):
     *    p = 1 / (4 * pi)
     */
    return INV_FOURPI;
}

Vector3f Warp::squareToUniformHemisphere(const Point2f &sample) {
    /* Hemisphere is the same as sphere, except that we convert the vector
     * with the wrong direction to the correct direction (0, 0, 1)
     */
    float z, theta, r;
    z = 2 * sample.x() - 1;
    theta = sample.y() * 2 * M_PI;
    r = sqrt(1 - z * z);
    return Vector3f(r * cos(theta), r * sin(theta), abs(z));
}

float Warp::squareToUniformHemispherePdf(const Vector3f &v) {
    /* The PDF of a 3D point is (the surface area of a hemisphere is 2 * pi):
     *    p = 1 / (2 * pi), z >= 0
     *      = 0           , otherwise
     */
    return (v.z() >= 0) ? INV_TWOPI : 0;
}

Vector3f Warp::squareToCosineHemisphere(const Point2f &sample) {
    /* Cosine hemisphere can be generated by first generate uniform samples
     * on disk, then project the points directly to the hemisphere. By nature,
     * its distribution will satisify the cosine property. */
    float r, theta;
    r = sqrt(sample.x());
    theta = sample.y() * 2 * M_PI;
    return Vector3f(r * cos(theta), r * sin(theta), sqrt(1 - r * r));
}

float Warp::squareToCosineHemispherePdf(const Vector3f &v) {
    /* The desired PDF is cos(theta) / pi, where theta is the angle between 
     * a point on the hemisphere and the north pole. Since all vector is of
     * length 1, the cosine of it will be z of the vector. We can change 
     * the PDF of uniform hemisphere to represent the change.
     */
    return (v.z() >= 0) ? (v.z() * INV_PI) : 0;
}

Vector3f Warp::squareToBeckmann(const Point2f &sample, float alpha) {
    /* After transformed into the spherical coordinates, the Beckmann 
     * distribution can be expressed using theta and phi. The distribution is
     * symmetric around the north pole, therefore, we can consider one dimension
     * at a time. To make the process easier to implement, instead of sampling
     * theta directly, sample tan(theta)^2 is more easy to perform.
     * The CDF of tan(theta)^2 = x is:
     *    y = 1 - e^(- x / alpha^2)
     * The inverse CDF is:
     *    x = - log(1 - y) * alpha^2
     * The CDF of the phi is:
     *    y = phi / (2 * pi), 0 <= phi <= 2 * pi
     * The inverse of CDF is:
     *    phi = y * 2 * pi
     */
    float logSample, tan2Theta, cosTheta, sinTheta, phi;
    logSample = std::log(1 - sample.x());
    if (isinf(logSample)) logSample = 0;
    tan2Theta = - logSample * alpha * alpha;
    cosTheta = 1 / sqrt(1 + tan2Theta);
    sinTheta = sqrt(1 - cosTheta * cosTheta);
    phi = sample.y() * 2 * M_PI;
    return Vector3f(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
}

float Warp::squareToBeckmannPdf(const Vector3f &m, float alpha) {
    /* To simplify the PDF representation, we substitude cos(theta) to x:
     * The PDF of a 3D point is:
     *    p = (1 / pi) * e^((x^2 -1) / (x^2 * alpha^2)) / (alpha^2 * x^3), 0 <= x <= 1
     *      = 0, otherwise
     */
    float cosTheta, cos2Theta, alpha2;
    cosTheta = m.z();
    cos2Theta = cosTheta * cosTheta;
    alpha2 = alpha * alpha;
    /* When cos(theta) = 0, there will be a division by zero problem, leading to the failure
     * of hypothesis test */
    return (cosTheta > 0) ? 
        (INV_PI * exp((cos2Theta - 1) / (cos2Theta * alpha2)) / (cos2Theta * cosTheta * alpha2)) : 0;
}

Point2f Warp::squareToHierarchical(const Point2f &sample, float mipMap[][1024*1024], uint32_t maxLevel){
    int x = 0, y = 0, rowSize = 1;
    float topSum, bottomSum, totSum;
    float verticalRatio, horizontalRatio;
    float sampleX = sample.x(), sampleY = sample.y();
    for (uint32_t i = 1; i <= maxLevel; ++i) {
        /* Warp vertically */
        rowSize *= 2;
        x *= 2;
        y *= 2;
        topSum = mipMap[i][x * rowSize + y] + mipMap[i][x * rowSize + y + 1];
        bottomSum = mipMap[i][(x + 1) * rowSize + y] + mipMap[i][(x + 1) * rowSize + y + 1];
        totSum = topSum + bottomSum;
        verticalRatio = topSum / totSum;

        if (sampleX < verticalRatio) {
            sampleX /= verticalRatio;
            horizontalRatio = mipMap[i][x * rowSize + y] / topSum;
        } else {
            x += 1;
            sampleX = (sampleX - verticalRatio) / (1 - verticalRatio);
            horizontalRatio = mipMap[i][x * rowSize + y] / bottomSum;
        }

        /* Warp horizontally */
        if (sampleY < horizontalRatio) {
            sampleY /= horizontalRatio;
        }
        else {
            y += 1;
            sampleY = (sampleY - horizontalRatio) / (1 - horizontalRatio);
        }
    }
    return Point2f(((float) x + sampleX) / rowSize, ((float) y + sampleY) / rowSize);
}

float Warp::squareToHierarchicalPdf(const Point2f &p, float mipMap[][1024*1024], uint32_t maxLevel){
    int rowSize = pow(2, maxLevel);
    int x =  p.x() * rowSize, y = p.y() * rowSize;
    return mipMap[maxLevel][x * rowSize + y] * rowSize * rowSize;
}

NORI_NAMESPACE_END
